-- ============================================
-- SOLUCIÓN: Importar datos en t_computo_observaciones
-- ============================================
-- 
-- Este script resuelve dos problemas:
-- 1. "cannot insert a non-DEFAULT value into column id_observacion" 
--    (columna GENERATED ALWAYS AS IDENTITY)
-- 2. "invalid input syntax for type bigint: """ 
--    (campos vacíos en id_equipo_computo)
-- ============================================

-- PASO 1: Cambiar GENERATED ALWAYS a GENERATED BY DEFAULT temporalmente
-- Esto permite importar datos con valores en id_observacion (o NULL)
-- Nota: Necesitamos usar una secuencia para esto
DO $$
DECLARE
    seq_name TEXT;
BEGIN
    -- Obtener el nombre de la secuencia asociada
    SELECT pg_get_serial_sequence('public.t_computo_observaciones', 'id_observacion') INTO seq_name;
    
    -- Si existe la secuencia, cambiar a GENERATED BY DEFAULT
    IF seq_name IS NOT NULL THEN
        -- Cambiar a GENERATED BY DEFAULT
        ALTER TABLE public.t_computo_observaciones 
        ALTER COLUMN id_observacion SET GENERATED BY DEFAULT;
    END IF;
END $$;

-- PASO 2: Eliminar el índice único y la foreign key temporalmente
DROP INDEX IF EXISTS public.idx_computo_observaciones_equipo;
ALTER TABLE public.t_computo_observaciones 
DROP CONSTRAINT IF EXISTS fk_equipo_computo_observaciones;

-- PASO 3: Cambiar temporalmente id_equipo_computo a TEXT para permitir importar cadenas vacías
ALTER TABLE public.t_computo_observaciones 
ALTER COLUMN id_equipo_computo TYPE TEXT USING id_equipo_computo::TEXT;

-- PASO 4: Permitir NULL en id_equipo_computo
ALTER TABLE public.t_computo_observaciones 
ALTER COLUMN id_equipo_computo DROP NOT NULL;

-- ============================================
-- AHORA IMPORTA TUS DATOS DESDE SUPABASE DASHBOARD
-- ============================================
-- Ve a Table Editor > t_computo_observaciones > Import data
-- Selecciona tu archivo y importa. Ahora debería funcionar sin errores.
-- 
-- NOTA: Si tu CSV tiene la columna id_observacion, puedes dejarla o eliminarla.
-- Si la dejas con valores NULL, se generarán automáticamente.
-- ============================================

-- PASO 5: Después de importar, ejecuta estas líneas para convertir y restaurar:

-- Convertir cadenas vacías y valores inválidos a NULL en id_equipo_computo
UPDATE public.t_computo_observaciones
SET id_equipo_computo = NULL
WHERE id_equipo_computo = '' 
   OR id_equipo_computo IS NULL
   OR TRIM(id_equipo_computo) = '';

-- Eliminar registros con valores que no se pueden convertir a BIGINT
DELETE FROM public.t_computo_observaciones
WHERE id_equipo_computo IS NOT NULL
  AND id_equipo_computo !~ '^\d+$'; -- Solo números enteros

-- Convertir la columna de vuelta a BIGINT
ALTER TABLE public.t_computo_observaciones 
ALTER COLUMN id_equipo_computo TYPE BIGINT 
USING CASE 
    WHEN id_equipo_computo IS NULL OR id_equipo_computo = '' THEN NULL
    WHEN id_equipo_computo ~ '^\d+$' THEN id_equipo_computo::BIGINT
    ELSE NULL
END;

-- Restaurar la foreign key (permitiendo NULL)
ALTER TABLE public.t_computo_observaciones
ADD CONSTRAINT fk_equipo_computo_observaciones 
    FOREIGN KEY (id_equipo_computo) 
    REFERENCES public.t_computo_detalles_generales(id_equipo_computo) 
    ON DELETE CASCADE;

-- PASO 6: Crear índice parcial único (permite múltiples NULL, pero valores únicos)
CREATE UNIQUE INDEX IF NOT EXISTS idx_computo_observaciones_equipo 
ON public.t_computo_observaciones(id_equipo_computo)
WHERE id_equipo_computo IS NOT NULL;

-- PASO 7: (Opcional) Volver a cambiar a GENERATED ALWAYS si prefieres
-- Esto es opcional. GENERATED BY DEFAULT también funciona bien.
-- Si quieres volver a GENERATED ALWAYS, descomenta la siguiente línea:
-- ALTER TABLE public.t_computo_observaciones 
-- ALTER COLUMN id_observacion SET GENERATED ALWAYS;

-- ============================================
-- RESULTADO
-- ============================================
-- Ahora la tabla:
-- ✅ id_observacion es GENERATED BY DEFAULT (permite importar con valores o NULL)
-- ✅ id_equipo_computo es BIGINT (tipo correcto)
-- ✅ Permite NULL en id_equipo_computo (puedes dejar campos vacíos)
-- ✅ Tiene foreign key (valida valores cuando los insertas)
-- ✅ Permite múltiples registros con NULL
-- ✅ Garantiza unicidad cuando hay valor
-- ✅ Puedes editar campos vacíos en el futuro sin problemas
-- ============================================

-- VERIFICACIÓN
SELECT 
    COUNT(*) as total_registros,
    COUNT(id_equipo_computo) as con_id_equipo,
    COUNT(*) - COUNT(id_equipo_computo) as sin_id_equipo,
    'Tabla lista para editar campos vacíos' as estado
FROM public.t_computo_observaciones;

